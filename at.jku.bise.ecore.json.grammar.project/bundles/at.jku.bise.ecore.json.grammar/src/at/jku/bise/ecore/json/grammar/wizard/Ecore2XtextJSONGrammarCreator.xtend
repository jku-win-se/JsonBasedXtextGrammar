package at.jku.bise.ecore.json.grammar.wizard

import org.eclipse.xtext.xtext.wizard.WizardConfiguration
import org.eclipse.emf.ecore.EClassifier
import static extension org.eclipse.xtext.xtext.wizard.ecore2xtext.Ecore2XtextExtensions.*
import static extension org.eclipse.xtext.xtext.wizard.ecore2xtext.UniqueNameUtil.*
import org.eclipse.emf.ecore.EClass
import java.util.List
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EEnum
import org.eclipse.emf.ecore.EDataType
import jsongrammar.JsonGrammar
import jsongrammar.DetailedGrammar
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.core.resources.IFile
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.common.util.URI

class Ecore2XtextJSONGrammarCreator {
	
	private DetailedGrammar detailedJsonGrammar = null;
	
	def grammar(WizardConfiguration config) {
		val it = config.ecore2Xtext
		val XtextJsonGrammarProjectInfo xtextJsonGrammarProject = config as XtextJsonGrammarProjectInfo;
		this.detailedJsonGrammar = loadJsonGrammar(xtextJsonGrammarProject.jsonGrammarFile,
				config.ecore2Xtext.rootElementClass.eResource.resourceSet
		).detaileGrammars.get(0);
		EcoreUtil.resolveAll(this.detailedJsonGrammar);
		defaultEPackageInfo.clearUniqueNames
		'''
			// automatically generated by Xtext JSON
			grammar «config.language.name» with org.eclipse.xtext.common.Terminals
			
			//TODO add referenced packages...JSONMM
			«FOR it: allReferencedEPackages»
				import "«nsURI»" «IF uniqueName !== null && uniqueName != ""»as «uniqueName»«ENDIF»
			«ENDFOR»
			
			«rootElementClass.rules»
			«FOR it:allDispatcherRuleClasses.but(rootElementClass)»
				«subClassDispatcherRule»
			«ENDFOR»	
			
			«FOR it:allConcreteRuleClassifiers.but(rootElementClass)»
				«rule(it)»
			«ENDFOR»		
		'''
	}
	
	def <T extends EClassifier> List<T> but(Iterable<T> classes, EClassifier it) {
		val retVal = classes.toList
		retVal.remove(it)
		return retVal
	}
	 
	def subClassDispatcherRule(EClass it) {
		'''
			«IF needsDispatcherRule»
				«uniqueName» returns «fqn»:
					«subClassAlternatives»;
			«ENDIF»
		'''
	}
	
	def subClassAlternatives(EClass eClazz) {
		var list = newArrayList(eClazz)+subClasses(eClazz)
		list=list.filter([c|needsConcreteRule(c)])
		list.map([concreteRuleName]).join(" | ")
	}
	
	def idAssignment(EClass it) {
		val idAttr = idAttribute
		if(idAttr!==null) {
			'''«idAttr.name»=«assignedRuleCall(idAttr)»'''
		}
	}
	
	def assigment(EStructuralFeature it) {
		if (it instanceof EAttribute) {
			'''
				//'"«Ecore2XtextJsonGrammarExtesions.assignmentKeyword(it)»"'«jsonSeparator»
				«it.assigmentStructuralFeature»«it.keyValue»
			'''	
		} else
			it.assigmentStructuralFeature
	}
	
	def assigmentStructuralFeature(EStructuralFeature it) {
		'''
			«IF(!required)»(«ENDIF»«Ecore2XtextJsonGrammarExtesions.assignmentKeyword(it)»«assignmentOperator»«assignedTerminal»«IF many»( "," «Ecore2XtextJsonGrammarExtesions.assignmentKeyword(it)»«assignmentOperator»«assignedTerminal»)*«ENDIF»«IF(!required)»)?«ENDIF»			
		'''
	}
	
	def assignedTerminal(EStructuralFeature it) {
		switch(it) {
			EAttribute:
				Ecore2XtextJsonGrammarExtesions.assignedRuleCall(it)
			EReference:
				if(containment)
					it.EReferenceType.uniqueName
				else
					'''[«it.EReferenceType.fqn»|EString]'''
			default:
				''''''
		}
	}

	def assignmentOperator(EStructuralFeature it) {
		'''«IF many»+=«ELSE»=«ENDIF»'''
	}
	
	def jsonSeparator(EStructuralFeature it) {
		'''«"'"»:«"'"»'''		
	}

	def rules(EClassifier it) {
		if (it !== null && it.needsConcreteRule) {
			ruleRoot(it)
		}
	}
	
	def ruleRoot(EClassifier it) {
		switch(it) {
			EClass :
				'''
				«it.concreteRuleName» returns «fqn»:
					«IF (it.onlyOptionalFeatures)»						
						{«fqn»}
					«ENDIF»
					«FOR strF: it.prefixFeatures»
						«strF.assigment»
					«ENDFOR»
					«idAssignment»«IF (!it.inlinedFeatures.empty)»
							«FOR attr: it.allAttributes»						 
								«attr.assigment»
							«ENDFOR»
							«FOR conti: it.allContainmentReferences»
								«conti.assigment»
							«ENDFOR»
					«ENDIF»;					
			'''
			EEnum:
				'''enum «name.quoteIfNeccesary» returns «fqn»:
				«it.ELiterals.map([name+" = '"+name+"'"]).join(' | ')»;'''
			EDataType:
				if (it.serializable) {
				'''
						«uniqueName» returns «fqn»:
							«it.dataTypeRuleBody»;
					'''
				}
			
			default:	
				throw new IllegalStateException("No rule template for "+it)
		}
	}
	
	def rule(EClassifier it) {
		switch(it) {
			EClass :
				'''
				«it.concreteRuleName» returns «fqn»:
					«IF (it.onlyOptionalFeatures)»						
						{«fqn»}
					«ENDIF»
					«FOR strF: it.prefixFeatures»
						«strF.assigment»
					«ENDFOR»
					«idAssignment»«IF (!it.inlinedFeatures.empty)»					
						«openParenthesis»«FOR attr: it.allAttributes»
							«attr.assigment»
						«ENDFOR»
						«FOR conti: it.allContainmentReferences»
							«conti.assigment»
						«ENDFOR»
					«closeParenthesis»«ENDIF»;					
			'''
			EEnum:
				'''enum «name.quoteIfNeccesary» returns «fqn»:
				«it.ELiterals.map([name+" = '"+name+"'"]).join(' | ')»;'''
			EDataType:
				if (it.serializable) {
				'''
						«uniqueName» returns «fqn»:
							«it.dataTypeRuleBody»;
					'''
				}
			
			default:	
				throw new IllegalStateException("No rule template for "+it)
		}
	}
	
	def closeParenthesis(EClass it) {
		if (needBraces) {
			'''«"'"»}«"'"»'''
		}
		else if (needBrackets)
			'''«"'"»]«"'"»'''	
			
	}
	
	def openParenthesis(EClass it) {
		if (needBraces) {
			'''«"'"»{«"'"»'''
		}
		else if (needBrackets)
			'''«"'"»[«"'"»'''			
	}
	
	def needBrackets(EClass it) {
		this.detailedJsonGrammar.bracketsEClass.contains(it) === true;
	}
	
	def boolean needBraces(EClass it) {		
		this.detailedJsonGrammar.curlyBracesEClass.contains(it) === true;
	}
	
	def keyValue(EAttribute it) {
		if (this.detailedJsonGrammar.keyValue.contains(it) === true) {
			'''«"'"»:«"'"»'''
		}
	}
	
	def JsonGrammar loadJsonGrammar(IFile jsonGrammarFile, ResourceSet reset) {
		val Resource resource = reset.getResource(URI.createPlatformResourceURI(jsonGrammarFile.getFullPath().toString(), true), true);
		if (resource.getContents().get(0) instanceof JsonGrammar) {
			return resource.getContents().get(0) as JsonGrammar;
		} else
			throw new IllegalArgumentException("Expecting JsonGrammar type of object");
	 }
}
