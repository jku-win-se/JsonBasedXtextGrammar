package at.jku.bise.ecore.json.grammar.wizard;

import at.jku.bise.ecore.json.grammar.wizard.XtextJsonGrammarProjectInfo;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.List;
import jsongrammar.DetailedGrammar;
import jsongrammar.JsonGrammar;
import org.eclipse.core.resources.IFile;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xtext.wizard.Ecore2XtextConfiguration;
import org.eclipse.xtext.xtext.wizard.WizardConfiguration;
import org.eclipse.xtext.xtext.wizard.ecore2xtext.Ecore2XtextExtensions;
import org.eclipse.xtext.xtext.wizard.ecore2xtext.UniqueNameUtil;

@SuppressWarnings("all")
public class Ecore2XtextJSONGrammarCreator {
  private DetailedGrammar detailedJsonGrammar = null;
  
  public CharSequence grammar(final WizardConfiguration config) {
    CharSequence _xblockexpression = null;
    {
      final Ecore2XtextConfiguration it = config.getEcore2Xtext();
      final XtextJsonGrammarProjectInfo xtextJsonGrammarProject = ((XtextJsonGrammarProjectInfo) config);
      this.detailedJsonGrammar = this.loadJsonGrammar(xtextJsonGrammarProject.getJsonGrammarFile(), 
        config.getEcore2Xtext().getRootElementClass().eResource().getResourceSet()).getDetailedGrammar();
      UniqueNameUtil.clearUniqueNames(it.getDefaultEPackageInfo());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("// automatically generated by Xtext JSON");
      _builder.newLine();
      _builder.append("grammar �config.language.name� with org.eclipse.xtext.common.Terminals");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�FOR it: allReferencedEPackages�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("import \"�nsURI�\" �IF uniqueName !== null && uniqueName != \"\"�as �uniqueName��ENDIF�");
      _builder.newLine();
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�rootElementClass.rules�");
      _builder.newLine();
      _builder.append("�FOR it:allDispatcherRuleClasses.but(rootElementClass)�");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�subClassDispatcherRule�");
      _builder.newLine();
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("�FOR it:allConcreteRuleClassifiers.but(rootElementClass)�");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�rule(it)�");
      _builder.newLine();
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public <T extends EClassifier> List<T> but(final Iterable<T> classes, final EClassifier it) {
    final List<T> retVal = IterableExtensions.<T>toList(classes);
    retVal.remove(it);
    return retVal;
  }
  
  public CharSequence subClassDispatcherRule(final EClass it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�IF needsDispatcherRule�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�uniqueName� returns �fqn�:");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�subClassAlternatives�;");
    _builder.newLine();
    _builder.append("�ENDIF�");
    _builder.newLine();
    return _builder;
  }
  
  public String subClassAlternatives(final EClass eClazz) {
    String _xblockexpression = null;
    {
      ArrayList<EClass> _newArrayList = CollectionLiterals.<EClass>newArrayList(eClazz);
      Iterable<EClass> _subClasses = Ecore2XtextExtensions.subClasses(eClazz);
      Iterable<EClass> list = Iterables.<EClass>concat(_newArrayList, _subClasses);
      final Function1<EClass, Boolean> _function = (EClass c) -> {
        return Boolean.valueOf(Ecore2XtextExtensions.needsConcreteRule(c));
      };
      list = IterableExtensions.<EClass>filter(list, _function);
      final Function1<EClass, String> _function_1 = (EClass it) -> {
        return Ecore2XtextExtensions.concreteRuleName(it);
      };
      _xblockexpression = IterableExtensions.join(IterableExtensions.<EClass, String>map(list, _function_1), " | ");
    }
    return _xblockexpression;
  }
  
  public CharSequence assigment(final EStructuralFeature it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�assignmentKeywordJSON(it)��IF it instanceof EReference��it.openParenthesis��ENDIF��IF(!required)�(�ENDIF��IF many��IF containment��ELSE�\'(\' �ENDIF��ENDIF��name.quoteIfNeccesary��assignmentOperator��assignedTerminal��IF many� ( \",\" �name.quoteIfNeccesary��assignmentOperator��assignedTerminal�)* �IF containment��ELSE�\')\' �ENDIF��ENDIF��IF (!required)�)?�ENDIF��IF it instanceof EReference��it.closeParenthesis��ENDIF�");
    _builder.newLine();
    _builder.append("�IF it instanceof EAttribute�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�IF it.isKeyValue�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�\"\'\"�:�\"\'\"�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�ENDIF�");
    _builder.newLine();
    _builder.append("�ENDIF�");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence assignedTerminal(final EStructuralFeature it) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (it instanceof EAttribute) {
      _matched=true;
      _switchResult = Ecore2XtextExtensions.assignedRuleCall(((EAttribute)it));
    }
    if (!_matched) {
      if (it instanceof EReference) {
        _matched=true;
        CharSequence _xifexpression = null;
        boolean _isContainment = ((EReference)it).isContainment();
        if (_isContainment) {
          _xifexpression = UniqueNameUtil.uniqueName(((EReference)it).getEReferenceType());
        } else {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("[�it.EReferenceType.fqn�|EString]");
          _xifexpression = _builder;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      StringConcatenation _builder = new StringConcatenation();
      _switchResult = _builder;
    }
    return _switchResult;
  }
  
  public CharSequence assignmentOperator(final EStructuralFeature it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�IF many�+=�ELSEIF isBoolean(EType)&&prefixBooleanFeature�?=�ELSE�=�ENDIF�");
    return _builder;
  }
  
  public CharSequence rules(final EClassifier it) {
    CharSequence _xifexpression = null;
    if (((it != null) && Ecore2XtextExtensions.needsConcreteRule(it))) {
      _xifexpression = this.rule(it);
    }
    return _xifexpression;
  }
  
  public CharSequence rule(final EClassifier it) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (it instanceof EClass) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("//EClass �it.name�");
      _builder.newLine();
      _builder.append("�it.concreteRuleName� returns �fqn�:");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�IF (it.onlyOptionalFeatures)�");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("{�fqn�}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�ENDIF�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�FOR strF: it.prefixFeatures�");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("�strF.assigment�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�openParenthesis�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�idAssignmentJSON(it)��IF (!it.inlinedFeatures.empty)�");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("�FOR attr: it.allAttributes�");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("�attr.assigment�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�FOR ref: it.allCrossReferences�");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("�ref.assigment�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�FOR conti: it.allContainmentReferences�");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("�conti.assigment�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�closeParenthesis��ENDIF�;");
      _builder.newLine();
      _switchResult = _builder;
    }
    if (!_matched) {
      if (it instanceof EEnum) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("enum �name.quoteIfNeccesary� returns �fqn�:");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("�it.ELiterals.map([name+\" = \'\"+name+\"\'\"]).join(\' | \')�;");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (it instanceof EDataType) {
        _matched=true;
        CharSequence _xifexpression = null;
        boolean _isSerializable = ((EDataType)it).isSerializable();
        if (_isSerializable) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("�uniqueName� returns �fqn�:");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("�it.dataTypeRuleBody�;");
          _builder.newLine();
          _xifexpression = _builder;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      throw new IllegalStateException(("No rule template for " + it));
    }
    return _switchResult;
  }
  
  public CharSequence jsonSeparator(final EStructuralFeature it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�\"\'\"�:�\"\'\"�");
    return _builder;
  }
  
  public boolean isKeyword(final EStructuralFeature it) {
    boolean _contains = this.detailedJsonGrammar.getKeywords().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public boolean isKeyValue(final EAttribute it) {
    boolean _contains = this.detailedJsonGrammar.getKeyValue().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public CharSequence assignmentKeywordJSON(final EStructuralFeature it) {
    CharSequence _xifexpression = null;
    boolean _isPrefixBooleanFeature = Ecore2XtextExtensions.isPrefixBooleanFeature(it);
    if (_isPrefixBooleanFeature) {
      _xifexpression = "";
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _isKeyword = this.isKeyword(it);
      if (_isKeyword) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("//Keywords");
        _builder.newLine();
        _builder.append("\'\"�it.name�\"\' �jsonSeparator�");
        _builder.newLine();
        _xifexpression_1 = _builder;
      } else {
        CharSequence _xifexpression_2 = null;
        if ((it instanceof EReference)) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("//EReference is not a keyword");
          _builder_1.newLine();
          _xifexpression_2 = _builder_1;
        } else {
          CharSequence _xifexpression_3 = null;
          if ((it instanceof EAttribute)) {
            CharSequence _xifexpression_4 = null;
            boolean _isKeyValue = this.isKeyValue(((EAttribute)it));
            if (_isKeyValue) {
              StringConcatenation _builder_2 = new StringConcatenation();
              _builder_2.append("//KeyValue");
              _builder_2.newLine();
              _xifexpression_4 = _builder_2;
            }
            _xifexpression_3 = _xifexpression_4;
          } else {
            String _name = it.getName();
            String _plus = ("\'" + _name);
            _xifexpression_3 = (_plus + "\' ");
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public CharSequence idAssignmentJSON(final EClass it) {
    CharSequence _xblockexpression = null;
    {
      InputOutput.<String>println(it.toString());
      final EAttribute idAttr = Ecore2XtextExtensions.idAttribute(it);
      CharSequence _xifexpression = null;
      if ((idAttr != null)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("//Keyword�s Name");
        _builder.newLine();
        _builder.append("�assigment(idAttr)�");
        _builder.newLine();
        _xifexpression = _builder;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public CharSequence closeParenthesis(final EClass it) {
    CharSequence _xifexpression = null;
    boolean _needBraces = this.needBraces(it);
    if (_needBraces) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("�\"\'\"�}�\"\'\"�");
      _xifexpression = _builder;
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _needBrackets = this.needBrackets(it);
      if (_needBrackets) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("�\"\'\"�]�\"\'\"�");
        _xifexpression_1 = _builder_1;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public CharSequence openParenthesis(final EClass it) {
    CharSequence _xifexpression = null;
    boolean _needBraces = this.needBraces(it);
    if (_needBraces) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("�\"\'\"�{�\"\'\"�");
      _xifexpression = _builder;
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _needBrackets = this.needBrackets(it);
      if (_needBrackets) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("�\"\'\"�[�\"\'\"�");
        _xifexpression_1 = _builder_1;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public boolean needBrackets(final EClass it) {
    boolean _contains = this.detailedJsonGrammar.getBracketsEClass().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public boolean needBraces(final EClass it) {
    boolean _contains = this.detailedJsonGrammar.getCurlyBracesEClass().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public CharSequence openParenthesis(final EReference it) {
    CharSequence _xifexpression = null;
    boolean _needBrackets = this.needBrackets(it);
    if (_needBrackets) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("�\"\'\"�[�\"\'\"�");
      _xifexpression = _builder;
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _needCurlyBraces = this.needCurlyBraces(it);
      if (_needCurlyBraces) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("�\"\'\"�{�\"\'\"�");
        _xifexpression_1 = _builder_1;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public CharSequence closeParenthesis(final EReference it) {
    CharSequence _xifexpression = null;
    boolean _needBrackets = this.needBrackets(it);
    if (_needBrackets) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("�\"\'\"�]�\"\'\"�");
      _xifexpression = _builder;
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _needCurlyBraces = this.needCurlyBraces(it);
      if (_needCurlyBraces) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("�\"\'\"�}�\"\'\"�");
        _xifexpression_1 = _builder_1;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public boolean needBrackets(final EReference it) {
    boolean _contains = this.detailedJsonGrammar.getBracketsReferences().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public boolean needCurlyBraces(final EReference it) {
    boolean _contains = this.detailedJsonGrammar.getCurlyBracesReferences().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public JsonGrammar loadJsonGrammar(final IFile jsonGrammarFile, final ResourceSet reset) {
    final Resource resource = reset.getResource(URI.createPlatformResourceURI(jsonGrammarFile.getFullPath().toString(), true), true);
    EObject _get = resource.getContents().get(0);
    if ((_get instanceof JsonGrammar)) {
      EObject _get_1 = resource.getContents().get(0);
      return ((JsonGrammar) _get_1);
    } else {
      throw new IllegalArgumentException("Expecting JsonGrammar type of object");
    }
  }
}
