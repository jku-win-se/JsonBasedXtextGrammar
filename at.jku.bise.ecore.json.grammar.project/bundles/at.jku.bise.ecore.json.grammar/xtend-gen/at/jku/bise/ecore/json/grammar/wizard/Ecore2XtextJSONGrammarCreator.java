package at.jku.bise.ecore.json.grammar.wizard;

import at.jku.bise.ecore.json.grammar.ui.utils.Ecore2XtextJSONExtensions;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import jsongrammar.DetailedGrammar;
import jsongrammar.JsonGrammar;
import org.eclipse.core.resources.IFile;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EEnum;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xtext.wizard.Ecore2XtextConfiguration;
import org.eclipse.xtext.xtext.wizard.WizardConfiguration;
import org.eclipse.xtext.xtext.wizard.ecore2xtext.UniqueNameUtil;

@SuppressWarnings("all")
public class Ecore2XtextJSONGrammarCreator {
  private DetailedGrammar detailedJsonGrammar = null;
  
  private Set<String> keywords = new HashSet<String>();
  
  public CharSequence grammar(final WizardConfiguration config) {
    CharSequence _xblockexpression = null;
    {
      final Ecore2XtextConfiguration it = config.getEcore2Xtext();
      final XtextJsonGrammarProjectInfo xtextJsonGrammarProject = ((XtextJsonGrammarProjectInfo) config);
      this.detailedJsonGrammar = this.loadJsonGrammar(xtextJsonGrammarProject.getJsonGrammarFile(), 
        config.getEcore2Xtext().getRootElementClass().eResource().getResourceSet()).getDetailedGrammar();
      UniqueNameUtil.clearUniqueNames(it.getDefaultEPackageInfo());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("// automatically generated by Xtext JSON");
      _builder.newLine();
      _builder.append("grammar �config.language.name� with org.eclipse.xtext.common.Terminals");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�FOR it: allReferencedEPackages�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("import \"�nsURI�\" �IF uniqueName !== null && uniqueName != \"\"�as �uniqueName��ENDIF�");
      _builder.newLine();
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�rootElementClass.rules�");
      _builder.newLine();
      _builder.append("�FOR it:allDispatcherRuleClasses.but(rootElementClass)�");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�subClassDispatcherRule�");
      _builder.newLine();
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("�FOR it:allConcreteRuleClassifiers.but(rootElementClass)�");
      _builder.newLine();
      _builder.append("\t");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�rule(it)�");
      _builder.newLine();
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�overwriteINT�");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�writeVALID_STRING�");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�overwriteSTRING()�");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�writeTerminalE_INT�");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�writeKeywords�");
      _builder.newLine();
      _builder.newLine();
      _builder.append("�writeTerminalE_DOUBLE�");
      _builder.newLine();
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public <T extends EClassifier> List<T> but(final Iterable<T> classes, final EClassifier it) {
    final List<T> retVal = IterableExtensions.<T>toList(classes);
    retVal.remove(it);
    return retVal;
  }
  
  public CharSequence subClassDispatcherRule(final EClass it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�IF needsDispatcherRule�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�uniqueName� returns �fqn�:");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�subClassAlternatives�;");
    _builder.newLine();
    _builder.append("�ENDIF�");
    _builder.newLine();
    return _builder;
  }
  
  /**
   * TODO work here with subclasses(eClazz) to have a list oredered as (1)Properties, (2) PatternProperties, (3) AdditionalProperties
   */
  public String subClassAlternatives(final EClass eClazz) {
    String _xblockexpression = null;
    {
      ArrayList<EClass> _newArrayList = CollectionLiterals.<EClass>newArrayList(eClazz);
      Iterable<EClass> _subClasses = Ecore2XtextJSONExtensions.subClasses(eClazz);
      Iterable<EClass> list = Iterables.<EClass>concat(_newArrayList, _subClasses);
      list = this.orderedSubClasses(list);
      final Function1<EClass, Boolean> _function = (EClass c) -> {
        return Boolean.valueOf(Ecore2XtextJSONExtensions.needsConcreteRule(c));
      };
      list = IterableExtensions.<EClass>filter(list, _function);
      final Function1<EClass, String> _function_1 = (EClass it) -> {
        String _xifexpression = null;
        boolean _needsSyntacticPredicate = this.needsSyntacticPredicate(it);
        if (_needsSyntacticPredicate) {
          String _concreteRuleName = Ecore2XtextJSONExtensions.concreteRuleName(it);
          _xifexpression = ("=>" + _concreteRuleName);
        } else {
          _xifexpression = Ecore2XtextJSONExtensions.concreteRuleName(it);
        }
        return _xifexpression;
      };
      _xblockexpression = IterableExtensions.join(IterableExtensions.<EClass, String>map(list, _function_1), " | ");
    }
    return _xblockexpression;
  }
  
  public boolean needsSyntacticPredicate(final EClass eClazz) {
    return ((this.isAdditionalProperty(eClazz) || this.isPatternProperty(eClazz)) || this.isIntegerInArrayOfTypes(eClazz));
  }
  
  /**
   * An Integer in an Array Of Types could generate an ambiguous grammar if there is also a Number
   */
  public boolean isIntegerInArrayOfTypes(final EClass eClazz) {
    final Function1<EAnnotation, Boolean> _function = (EAnnotation annotation) -> {
      return Boolean.valueOf(annotation.getDetails().get("ArrayOfTypes").equals("integer"));
    };
    return IterableExtensions.<EAnnotation>exists(eClazz.getEAnnotations(), _function);
  }
  
  public boolean isAdditionalProperty(final EClass eClazz) {
    final Function1<EAnnotation, Boolean> _function = (EAnnotation annotation) -> {
      return Boolean.valueOf(annotation.getDetails().containsKey("AdditionalProperties"));
    };
    return IterableExtensions.<EAnnotation>exists(eClazz.getEAnnotations(), _function);
  }
  
  public boolean isPatternProperty(final EClass eClazz) {
    final Function1<EAnnotation, Boolean> _function = (EAnnotation annotation) -> {
      return Boolean.valueOf(annotation.getDetails().containsKey("PatternProperties"));
    };
    return IterableExtensions.<EAnnotation>exists(eClazz.getEAnnotations(), _function);
  }
  
  public ArrayList<EClass> orderedSubClasses(final Iterable<EClass> alternativeEClasses) {
    ArrayList<EClass> _xblockexpression = null;
    {
      ArrayList<EClass> propertiesEClasses = new ArrayList<EClass>();
      ArrayList<EClass> patternPropertiesEClasses = new ArrayList<EClass>();
      EClass additionalPropertiesEClass = null;
      ArrayList<EClass> orderedSubClasses = new ArrayList<EClass>();
      for (final EClass eClass : alternativeEClasses) {
        {
          boolean isPatternOrAdditionalProperty = false;
          if ((!isPatternOrAdditionalProperty)) {
            boolean _isAdditionalProperty = this.isAdditionalProperty(eClass);
            if (_isAdditionalProperty) {
              isPatternOrAdditionalProperty = true;
              additionalPropertiesEClass = eClass;
            } else {
              boolean _isPatternProperty = this.isPatternProperty(eClass);
              if (_isPatternProperty) {
                isPatternOrAdditionalProperty = true;
                patternPropertiesEClasses.add(eClass);
              }
            }
          }
          if ((!isPatternOrAdditionalProperty)) {
            propertiesEClasses.add(eClass);
          }
        }
      }
      orderedSubClasses.addAll(propertiesEClasses);
      orderedSubClasses.addAll(patternPropertiesEClasses);
      if ((additionalPropertiesEClass != null)) {
        orderedSubClasses.add(additionalPropertiesEClass);
      }
      _xblockexpression = orderedSubClasses;
    }
    return _xblockexpression;
  }
  
  public CharSequence assigment(final EStructuralFeature it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�assignmentKeywordJSON(it)��IF it instanceof EReference��it.openParenthesis��ENDIF��IF(!required)�(�ENDIF��IF many��IF containment��ELSE�\'(\' �ENDIF��ENDIF��name.quoteIfNeccesary��assignmentOperator��assignedTerminal��IF many� ( \",\" �name.quoteIfNeccesary��assignmentOperator��assignedTerminal�)* �IF containment��ELSE�\')\' �ENDIF��ENDIF��IF (!required)�)?�ENDIF��IF it instanceof EReference��it.closeParenthesis��ENDIF�");
    _builder.newLine();
    _builder.append("�IF it instanceof EAttribute�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�IF it.isKeyValue�");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("�\"\'\"�:�\"\'\"�");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("�ENDIF�");
    _builder.newLine();
    _builder.append("�ENDIF�");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence assignedTerminal(final EStructuralFeature it) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (it instanceof EAttribute) {
      _matched=true;
      _switchResult = Ecore2XtextJSONExtensions.assignedJSONRuleCall(((EAttribute)it));
    }
    if (!_matched) {
      if (it instanceof EReference) {
        _matched=true;
        CharSequence _xifexpression = null;
        boolean _isContainment = ((EReference)it).isContainment();
        if (_isContainment) {
          _xifexpression = UniqueNameUtil.uniqueName(((EReference)it).getEReferenceType());
        } else {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("[�it.EReferenceType.fqn�|EString]");
          _xifexpression = _builder;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      StringConcatenation _builder = new StringConcatenation();
      _switchResult = _builder;
    }
    return _switchResult;
  }
  
  public CharSequence assignmentOperator(final EStructuralFeature it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�IF many�+=�ELSE�=�ENDIF�");
    return _builder;
  }
  
  public CharSequence rules(final EClassifier it) {
    CharSequence _xifexpression = null;
    if (((it != null) && Ecore2XtextJSONExtensions.needsConcreteRule(it))) {
      _xifexpression = this.rule(it);
    }
    return _xifexpression;
  }
  
  /**
   * To make sure that if there is a feature named 'key', it comes first
   */
  public ArrayList<EStructuralFeature> orderByKeyValue(final EClassifier eClassifier) {
    ArrayList<EStructuralFeature> _xblockexpression = null;
    {
      final EClass it = ((EClass) eClassifier);
      ArrayList<EStructuralFeature> orderByKeyValue = new ArrayList<EStructuralFeature>();
      final Function1<EStructuralFeature, Boolean> _function = (EStructuralFeature eStructuralFeature) -> {
        return Boolean.valueOf(eStructuralFeature.getName().equals("key"));
      };
      Iterables.<EStructuralFeature>addAll(orderByKeyValue, IterableExtensions.<EStructuralFeature>filter(Ecore2XtextJSONExtensions.prefixFeatures(it), _function));
      final Function1<EStructuralFeature, Boolean> _function_1 = (EStructuralFeature eStructuralFeature) -> {
        boolean _equals = eStructuralFeature.getName().equals("key");
        return Boolean.valueOf((!_equals));
      };
      Iterables.<EStructuralFeature>addAll(orderByKeyValue, IterableExtensions.<EStructuralFeature>filter(Ecore2XtextJSONExtensions.prefixFeatures(it), _function_1));
      _xblockexpression = orderByKeyValue;
    }
    return _xblockexpression;
  }
  
  public CharSequence rule(final EClassifier it) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (it instanceof EClass) {
      _matched=true;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("//EClass �it.name�");
      _builder.newLine();
      _builder.append("�it.concreteRuleName� returns �fqn�:");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�IF (it.onlyOptionalFeatures)�");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("{�fqn�}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�ENDIF�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�FOR strF: it.orderByKeyValue /*it.prefixFeatures*/�  ");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("�strF.assigment�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�openParenthesis�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�idAssignmentJSON(it)��IF (!it.inlinedFeatures.empty)�");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("�FOR attr: it.allAttributes�");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("�attr.assigment�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�FOR ref: it.allCrossReferences�");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("�ref.assigment�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�FOR conti: it.allContainmentReferences�");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("�conti.assigment�");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("�closeParenthesis��ENDIF�;");
      _builder.newLine();
      _switchResult = _builder;
    }
    if (!_matched) {
      if (it instanceof EEnum) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("enum �name.quoteIfNeccesary� returns �fqn�:");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        _builder.append("�it.ELiterals.map([name+\" = \'\"+name+\"\'\"]).join(\' | \')�;");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (it instanceof EDataType) {
        _matched=true;
        CharSequence _xifexpression = null;
        boolean _isSerializable = ((EDataType)it).isSerializable();
        if (_isSerializable) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("�uniqueName� returns �fqn�:");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("�it.jsonDataTypeRuleBody�;");
          _builder.newLine();
          _xifexpression = _builder;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      throw new IllegalStateException(("No rule template for " + it));
    }
    return _switchResult;
  }
  
  public static String jsonDataTypeRuleBody(final EDataType it) {
    String _switchResult = null;
    String _name = it.getName();
    if (_name != null) {
      switch (_name) {
        case "EString":
          _switchResult = "VALID_STRING";
          break;
        case "EDouble":
          _switchResult = "E_INT | E_DOUBLE";
          break;
        case "EInt":
          _switchResult = "E_INT";
          break;
        default:
          _switchResult = Ecore2XtextJSONExtensions.dataTypeRuleBody(it);
          break;
      }
    } else {
      _switchResult = Ecore2XtextJSONExtensions.dataTypeRuleBody(it);
    }
    return _switchResult;
  }
  
  public CharSequence jsonSeparator(final EStructuralFeature it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("�\"\'\"�:�\"\'\"�");
    return _builder;
  }
  
  public boolean isKeyword(final EStructuralFeature it) {
    boolean _contains = this.detailedJsonGrammar.getKeywords().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public boolean isKeyValue(final EAttribute it) {
    boolean _contains = this.detailedJsonGrammar.getKeyValue().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public CharSequence assignmentKeywordJSON(final EStructuralFeature it) {
    CharSequence _xifexpression = null;
    boolean _isKeyword = this.isKeyword(it);
    if (_isKeyword) {
      CharSequence _xblockexpression = null;
      {
        this.keywords.add(it.getName());
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("//Keywords");
        _builder.newLine();
        _builder.append("\'\"�it.name�\"\' �jsonSeparator�");
        _builder.newLine();
        _xblockexpression = _builder;
      }
      _xifexpression = _xblockexpression;
    } else {
      CharSequence _xifexpression_1 = null;
      if ((it instanceof EReference)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("//EReference is not a keyword");
        _builder.newLine();
        _xifexpression_1 = _builder;
      } else {
        CharSequence _xifexpression_2 = null;
        if ((it instanceof EAttribute)) {
          CharSequence _xifexpression_3 = null;
          boolean _isKeyValue = this.isKeyValue(((EAttribute)it));
          if (_isKeyValue) {
            StringConcatenation _builder_1 = new StringConcatenation();
            _builder_1.append("//KeyValue");
            _builder_1.newLine();
            _xifexpression_3 = _builder_1;
          }
          _xifexpression_2 = _xifexpression_3;
        } else {
          String _name = it.getName();
          String _plus = ("\'" + _name);
          _xifexpression_2 = (_plus + "\' ");
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public CharSequence idAssignmentJSON(final EClass it) {
    CharSequence _xblockexpression = null;
    {
      InputOutput.<String>println(it.toString());
      final EAttribute idAttr = Ecore2XtextJSONExtensions.idAttribute(it);
      CharSequence _xifexpression = null;
      if ((idAttr != null)) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("//Keyword�s Name");
        _builder.newLine();
        _builder.append("�assigment(idAttr)�");
        _builder.newLine();
        _xifexpression = _builder;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public CharSequence closeParenthesis(final EClass it) {
    CharSequence _xifexpression = null;
    boolean _needBraces = this.needBraces(it);
    if (_needBraces) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("�\"\'\"�}�\"\'\"�");
      _xifexpression = _builder;
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _needBrackets = this.needBrackets(it);
      if (_needBrackets) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("�\"\'\"�]�\"\'\"�");
        _xifexpression_1 = _builder_1;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public CharSequence openParenthesis(final EClass it) {
    CharSequence _xifexpression = null;
    boolean _needBraces = this.needBraces(it);
    if (_needBraces) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("�\"\'\"�{�\"\'\"�");
      _xifexpression = _builder;
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _needBrackets = this.needBrackets(it);
      if (_needBrackets) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("�\"\'\"�[�\"\'\"�");
        _xifexpression_1 = _builder_1;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public boolean needBrackets(final EClass it) {
    boolean _contains = this.detailedJsonGrammar.getBracketsEClass().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public boolean needBraces(final EClass it) {
    boolean _contains = this.detailedJsonGrammar.getCurlyBracesEClass().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public CharSequence openParenthesis(final EReference it) {
    CharSequence _xifexpression = null;
    boolean _needBrackets = this.needBrackets(it);
    if (_needBrackets) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("�\"\'\"�[�\"\'\"�");
      _xifexpression = _builder;
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _needCurlyBraces = this.needCurlyBraces(it);
      if (_needCurlyBraces) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("�\"\'\"�{�\"\'\"�");
        _xifexpression_1 = _builder_1;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public CharSequence closeParenthesis(final EReference it) {
    CharSequence _xifexpression = null;
    boolean _needBrackets = this.needBrackets(it);
    if (_needBrackets) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("�\"\'\"�]�\"\'\"�");
      _xifexpression = _builder;
    } else {
      CharSequence _xifexpression_1 = null;
      boolean _needCurlyBraces = this.needCurlyBraces(it);
      if (_needCurlyBraces) {
        StringConcatenation _builder_1 = new StringConcatenation();
        _builder_1.append("�\"\'\"�}�\"\'\"�");
        _xifexpression_1 = _builder_1;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  public boolean needBrackets(final EReference it) {
    boolean _contains = this.detailedJsonGrammar.getBracketsReferences().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public boolean needCurlyBraces(final EReference it) {
    boolean _contains = this.detailedJsonGrammar.getCurlyBracesReferences().contains(it);
    return (Boolean.valueOf(_contains) == Boolean.valueOf(true));
  }
  
  public JsonGrammar loadJsonGrammar(final IFile jsonGrammarFile, final ResourceSet reset) {
    final Resource resource = reset.getResource(URI.createPlatformResourceURI(jsonGrammarFile.getFullPath().toString(), true), true);
    EObject _get = resource.getContents().get(0);
    if ((_get instanceof JsonGrammar)) {
      EObject _get_1 = resource.getContents().get(0);
      return ((JsonGrammar) _get_1);
    } else {
      throw new IllegalArgumentException("Expecting JsonGrammar type of object");
    }
  }
  
  public CharSequence overwriteINT() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/**");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* In JSON the first digit of an integer can not be 0, unless it is 0 itself.");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("@Override ");
    _builder.newLine();
    _builder.append("terminal INT returns ecore::EInt: ");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("(\'0\' |  ((\'1\'..\'9\') (\'0\'..\'9\')*))");
    _builder.newLine();
    _builder.append(";");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence writeVALID_STRING() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("VALID_STRING: STRING  | KEYWORD;");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence overwriteSTRING() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("/**");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("* In JSON the single quote for String is not admitted");
    _builder.newLine();
    _builder.append(" ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("@Override ");
    _builder.newLine();
    _builder.append("terminal STRING:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\'\"\' ( \'\\\\\' . /* \'b\'|\'t\'|\'n\'|\'f\'|\'r\'|\'u\'|\'\"\'|\"\'\"|\'\\\\\' */ | !(\'\\\\\'|\'\"\') )* \'\"\'");
    _builder.newLine();
    _builder.append(";\t");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence writeTerminalE_INT() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("terminal E_INT :");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\'-\'? INT;");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence writeKeywords() {
    CharSequence _xifexpression = null;
    boolean _isEmpty = this.keywords.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("KEYWORD: �FOR it: this.keywords SEPARATOR \' | \'� ");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("\'\"�it�\"\' ");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("�ENDFOR�");
      _builder.newLine();
      _builder.append(";");
      _builder.newLine();
      _builder.newLine();
      _xifexpression = _builder;
    } else {
      _xifexpression = "";
    }
    return _xifexpression;
  }
  
  public CharSequence writeTerminalE_DOUBLE() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("terminal E_DOUBLE :");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("\'-\'? INT (\'.\' INT+)? ((\'E\'|\'e\') (\'+\'|\'-\')? INT)?");
    _builder.newLine();
    _builder.append(";");
    _builder.newLine();
    _builder.newLine();
    return _builder;
  }
}
